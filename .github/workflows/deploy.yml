name: Deploy to ECS Fargate

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Verify Dockerfile presence
        run: |
          echo "Checking for Dockerfile..."
          ls -la myjavaapp
          if [ ! -f myjavaapp/Dockerfile ]; then
            echo "Dockerfile not found!"
            exit 1
          fi
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Build Docker image
        run: |
          IMAGE_TAG=${{ github.sha }}
          docker build -t ${{ secrets.ECR_REPOSITORY }}:$IMAGE_TAG myjavaapp/

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Tag & push image to ECR
        run: |
          IMAGE_TAG=${{ github.sha }}
          ECR_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ secrets.ECR_REPOSITORY }}:$IMAGE_TAG"
          docker tag ${{ secrets.ECR_REPOSITORY }}:$IMAGE_TAG $ECR_URI
          docker push $ECR_URI
          echo "IMAGE=$ECR_URI" >> $GITHUB_ENV

      - name: Capture current task definition revision
        id: prev
        run: |
          TD=$(aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE }} \
            --region $AWS_REGION \
            --query "services[0].taskDefinition" --output text)
          echo "Previous task definition ARN: $TD"
          echo "::set-output name=revision::$(echo "$TD" | awk -F ':' '{print $NF}')"

      - name: Register updated task definition
        run: |
          IMAGE="$IMAGE"
          TD_JSON=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.TASK_DEFINITION_NAME }} \
            --region $AWS_REGION)
          UPDATED=$(echo "$TD_JSON" | jq --arg IMAGE "$IMAGE" '
            .taskDefinition as $td |
            {
              family: $td.family,
              taskRoleArn: ($td.taskRoleArn // ""),
              executionRoleArn: ($td.executionRoleArn // ""),
              networkMode: $td.networkMode,
              containerDefinitions:
                ($td.containerDefinitions |
                  map(if .name == "Democontainer" then .image = $IMAGE else . end)),
              volumes: $td.volumes,
              placementConstraints: $td.placementConstraints,
              requiresCompatibilities: $td.requiresCompatibilities,
              cpu: $td.cpu,
              memory: $td.memory,
              runtimePlatform: $td.runtimePlatform
            }
          ')
          echo "$UPDATED" > updated_task_def.json
          aws ecs register-task-definition --cli-input-json file://updated_task_def.json --region $AWS_REGION

      - name: Deploy or Rollback with safeties (never fail)
        run: |
          PREV=${{ steps.prev.outputs.revision }}
          NEW=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.TASK_DEFINITION_NAME }} \
            --region $AWS_REGION \
            --query "taskDefinition.revision" --output text)

          echo "Previous revision: $PREV, New revision: $NEW"

          echo "Updating service to new revision..."
          set +e
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE }} \
            --task-definition ${{ secrets.TASK_DEFINITION_NAME }}:$NEW \
            --region $AWS_REGION \
            --force-new-deployment
          RET=$?
          set -e

          if [ "$RET" -ne 0 ] || [ -z "$NEW" ]; then
            echo "Deployment failed or invalid new revision. Rolling back to ${PREV}..."
            aws ecs update-service \
              --cluster ${{ secrets.ECS_CLUSTER }} \
              --service ${{ secrets.ECS_SERVICE }} \
              --task-definition ${{ secrets.TASK_DEFINITION_NAME }}:$PREV \
              --region $AWS_REGION \
              --force-new-deployment
            echo "Rollback completed."
          else
            echo "Deployment succeeded using revision $NEW."
          fi

      - name: Cleanup old images in ECR (keep latest 5)
        run: |
          REPO=${{ secrets.ECR_REPOSITORY }}
          IMAGE_IDS=$(aws ecr list-images --repository-name $REPO --region $AWS_REGION \
            --query 'imageIds[*]' --output json)
          IMAGES=($(echo $IMAGE_IDS | jq -r '.[].imageDigest'))
          COUNT=${#IMAGES[@]}

          if [ "$COUNT" -le 5 ]; then
            echo "No cleanup needed. Only $COUNT images."
          else
            TO_DELETE=("${IMAGES[@]:0:$((COUNT-5))}")
            for DIGEST in "${TO_DELETE[@]}"; do
              aws ecr batch-delete-image --repository-name $REPO --region $AWS_REGION --image-ids imageDigest=$DIGEST
              echo "Deleted old image: $DIGEST"
            done
          fi
