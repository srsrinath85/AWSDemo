name: Deploy to ECS Fargate with Auto Versioning and Rollback

on:
  push:
    branches:
      - main

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
  TASK_DEFINITION_NAME: ${{ secrets.TASK_DEFINITION_NAME }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Validate Dockerfile
        run: |
          if [ ! -f myjavaapp/Dockerfile ]; then
            echo "❌ Dockerfile not found in myjavaapp!"
            exit 1
          fi
          echo "✅ Dockerfile found."

      - name: Set AWS region
        run: aws configure set region $AWS_REGION

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get last deployed task definition revision
        id: get-current-revision
        run: |
          REVISION=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --region $AWS_REGION \
            --query "services[0].taskDefinition" --output text | awk -F':' '{print $2}')
          echo "CURRENT_REVISION=$REVISION" >> $GITHUB_ENV
          echo "Current deployed task definition revision: $REVISION"

      - name: Calculate new image tag version (v1, v2, ...)
        id: calc-version
        run: |
          if [ -z "$CURRENT_REVISION" ]; then
            echo "No current revision found, starting from v1"
            echo "IMAGE_TAG=v1" >> $GITHUB_ENV
          else
            # Strip leading 'v' and convert to number, increment by 1
            CURRENT_VER_NUM=$(echo "$CURRENT_REVISION" | sed 's/^v//' || echo "0")
            # If it's not a number, fallback to 0
            if ! [[ "$CURRENT_VER_NUM" =~ ^[0-9]+$ ]]; then
              CURRENT_VER_NUM=0
            fi
            NEW_VER_NUM=$((CURRENT_VER_NUM + 1))
            echo "IMAGE_TAG=v$NEW_VER_NUM" >> $GITHUB_ENV
          fi
          echo "New image tag will be $IMAGE_TAG"

      - name: Build, tag, and push Docker image
        run: |
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG myjavaapp/
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ Docker image pushed with tag: $IMAGE_TAG"

      - name: Get current task definition JSON
        run: aws ecs describe-task-definition \
          --task-definition $TASK_DEFINITION_NAME \
          --region $AWS_REGION > current_task_def.json

      - name: Register new ECS task definition with updated image
        id: register-task-def
        run: |
          IMAGE="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG"

          NEW_TASK_DEF=$(jq --arg IMAGE "$IMAGE" '.taskDefinition |
            {
              family: .family,
              taskRoleArn: (.taskRoleArn // ""),
              executionRoleArn: (.executionRoleArn // ""),
              networkMode: .networkMode,
              containerDefinitions: (.containerDefinitions | map(
                if .name == "Democontainer" then
                  .image = $IMAGE | .memory = (.memory // 512)
                else
                  .
                end
              )),
              volumes: .volumes,
              placementConstraints: .placementConstraints,
              requiresCompatibilities: .requiresCompatibilities,
              cpu: .cpu,
              memory: .memory,
              runtimePlatform: .runtimePlatform
            }' current_task_def.json)

          echo "$NEW_TASK_DEF" > updated_task_def.json

          aws ecs register-task-definition \
            --region $AWS_REGION \
            --cli-input-json file://updated_task_def.json > registered_task_def.json

          NEW_REVISION=$(jq -r '.taskDefinition.revision' registered_task_def.json)
          echo "NEW_TASK_DEF_REVISION=$NEW_REVISION" >> $GITHUB_ENV
          echo "Registered new task definition revision: $NEW_REVISION"

      - name: Save previous task definition revision for rollback
        run: echo "PREVIOUS_TASK_DEF_REVISION=$CURRENT_REVISION" >> $GITHUB_ENV

      - name: Update ECS Service to use the new task definition
        run: |
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $TASK_DEFINITION_NAME:$NEW_TASK_DEF_REVISION \
            --region $AWS_REGION \
            --force-new-deployment
          echo "Updated ECS service to new task definition revision $NEW_TASK_DEF_REVISION"

      - name: Wait for ECS service to stabilize
        run: |
          set +e
          aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION
          STATUS=$?
          set -e
          if [ $STATUS -ne 0 ]; then
            echo "Deployment failed, rolling back..."
            exit 1
          else
            echo "Deployment succeeded and service is stable."
          fi

      - name: Rollback if deployment failed
        if: failure()
        run: |
          echo "Rolling back to previous task definition revision: $PREVIOUS_TASK_DEF_REVISION"
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $TASK_DEFINITION_NAME:$PREVIOUS_TASK_DEF_REVISION \
            --region $AWS_REGION \
            --force-new-deployment
          echo "Rollback initiated."

      - name: Cleanup old ECR images (keep latest 5)
        run: |
          IMAGE_IDS=$(aws ecr describe-images --repository-name $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'sort_by(imageDetails,& imagePushedAt)[].imageDigest' \
            --output text)

          IMAGE_ARRAY=($IMAGE_IDS)
          COUNT=${#IMAGE_ARRAY[@]}

          if [ $COUNT -le 5 ]; then
            echo "No images to clean up."
            exit 0
          fi

          DELETE_DIGESTS=("${IMAGE_ARRAY[@]:0:$((COUNT - 5))}")

          for DIGEST in "${DELETE_DIGESTS[@]}"; do
            aws ecr batch-delete-image --repository-name $ECR_REPOSITORY --region $AWS_REGION --image-ids imageDigest=$DIGEST
            echo "Deleted old image digest: $DIGEST"
          done

          echo "Cleanup complete."
